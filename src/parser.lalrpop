use crate::ast::*;

grammar;

// declaration 
// declaration_specifier    init_declarator_list    ;
// type_specifier           init_declarator
// int                      declarator
//                          direct_declarator
//                          x

// declaration
// 	: declaration_specifiers ';'
// 	| declaration_specifiers init_declarator_list ';'
// 	;
pub Declaration: Box<Decl> = {
    <specs:DeclarationSpecifiers> ";" => Box::new(Decl::Decl(specs)),
};

// declaration_specifiers
// 	: storage_class_specifier
// 	| storage_class_specifier declaration_specifiers
// 	| type_specifier
// 	| type_specifier declaration_specifiers
//  ;
pub DeclarationSpecifiers: Box<DeclSpecs> = {
    <tspecs:TypeSpecifier> => Box::new(DeclSpecs::Type(tspecs)),
};

// init_declarator_list
// 	: init_declarator
// 	| init_declarator_list ',' init_declarator
// 	;
pub InitDeclaratorList = Comma<InitDeclarator>;

// init_declarator
// 	: declarator
// 	| declarator '=' initializer
// 	;
pub InitDeclarator: Box<InitDecl> = {
    <decl: Declarator> => Box::new(InitDecl::Decl(*decl)),
    // Declarator "=" Initializer,
};

// declarator
// 	: pointer direct_declarator
// 	| direct_declarator
// 	;
pub Declarator: Box<Declarator> = {
    <ddecl: DirectDeclarator> => Box::new(Declarator::ValDecl(*ddecl)),
};

// direct_declarator
// 	: IDENTIFIER
// 	| '(' declarator ')'
// 	| direct_declarator '[' constant_expression ']'
// 	| direct_declarator '[' ']'
// 	| direct_declarator '(' parameter_type_list ')'
// 	| direct_declarator '(' identifier_list ')'
// 	| direct_declarator '(' ')'
// 	;
pub DirectDeclarator: Box<DirDeclarator> = {
    <s:StrLiteral> => Box::new(DirDeclarator::Id(s)),
};

pub TypeSpecifier: TypeSpec = {
    "int" => TypeSpec::Int,
};

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")+> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

StrLiteral: String = {
    <s:r"'[^']*'"> => s.trim_matches('\'').to_string(),
};